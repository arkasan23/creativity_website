<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interactive Creativity Website</title>
    <style>
      :root {
        --bg: #0b0d12;
        --panel: #11131a;
        --panel-2: #0f1220;
        --text: #e7ecf3;
        --muted: #9aa4b2;
        --accent: #6ee7ff;
        --accent-2: #a78bfa;
        --ring: #2dd4bf;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font:
          16px/1.6 system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          Inter,
          "Helvetica Neue",
          Arial;
        color: var(--text);
        background:
          radial-gradient(
            1200px 800px at 80% -10%,
            #1a2142 0%,
            transparent 60%
          ),
          var(--bg);
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 28px 20px 56px;
      }
      header {
        display: grid;
        gap: 12px;
        align-items: end;
        grid-template-columns: 1fr auto;
        margin-bottom: 18px;
      }
      h1 {
        margin: 0;
        font-size: clamp(26px, 4.2vw, 40px);
        letter-spacing: 0.4px;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #051017;
        padding: 6px 12px;
        border-radius: 999px;
        font-weight: 700;
      }
      .grid {
        display: grid;
        gap: 18px;
        grid-template-columns: 1.1fr 0.9fr;
      }
      @media (max-width: 880px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 18px;
        padding: 18px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
      }
      .card h2 {
        margin: 0 0 8px;
        font-size: 20px;
      }
      .card p {
        margin: 0 0 10px;
        color: var(--muted);
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        margin: 8px 0 12px;
      }
      label {
        font-size: 13px;
        color: var(--muted);
      }
      input[type="color"],
      input[type="range"],
      button,
      select {
        background: var(--panel);
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        padding: 8px 10px;
        outline: none;
      }
      input[type="color"] {
        padding: 0;
        height: 36px;
        width: 48px;
      }
      input[type="range"] {
        height: 36px;
      }
      button {
        cursor: pointer;
        transition:
          transform 0.05s ease,
          box-shadow 0.2s;
      }
      button:hover {
        box-shadow: 0 0 0 2px var(--ring) inset;
      }
      button:active {
        transform: translateY(1px);
      }

      canvas {
        display: block;
        width: 100%;
        background: conic-gradient(
          from 180deg at 50% 50%,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0.01)
        );
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      #drawCanvas {
        aspect-ratio: 4 / 3;
      }
      #glCanvas {
        aspect-ratio: 16 / 10;
      }

      footer {
        margin-top: 28px;
        color: var(--muted);
        text-align: center;
      }
      a {
        color: var(--accent);
      }
      .pill {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.09);
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Interactive Creativity Website</h1>
          <p class="pill">Creativity</p>
        </div>
        <span class="badge" title="Course-aligned">Creative Theories</span>
      </header>

      <div class="grid">
        <section class="card">
          <h2>About</h2>
          <p>
            This website is an original creation that demonstrates learning from
            creativity theory.
          </p>
          <h3 style="margin: 14px 0 8px">Why a website</h3>
          <p>
            It combines design, interactivity, and systems thinking. It's
            perfect for applying creativity theories in a computer science
            context. It’s also shareable, iterative, and user centered.
          </p>

          <h2 style="margin-top: 16px">Drawing Canvas</h2>
          <p>Create quick sketches. Express your self. Download your sketch.</p>
          <div class="toolbar" aria-label="Drawing toolbar">
            <label
              >Brush color <input type="color" id="color" value="#7EE3FF"
            /></label>
            <label
              >Brush size
              <input type="range" id="size" min="1" max="40" value="6"
            /></label>
            <button id="toolPen">Pen</button>
            <button id="toolEraser">Eraser</button>
            <button id="clear">Clear</button>
            <button id="save">Download PNG</button>
          </div>
          <canvas id="drawCanvas" width="900" height="675"></canvas>
        </section>

        <section class="card">
          <h2>Rotating Cube</h2>
          <p>
            I wanted to integrate what I’ve learned from my courses in my degree
            such as my computer graphic course so I decided to make something
            creative with that knowledge. Right now this is something I quickly
            put up but I want to add something more complex and interesting for
            the final draft.
          </p>
          <div class="toolbar">
            <label
              >Rotation
              <input type="range" id="speed" min="0" max="10" value="5"
            /></label>
            <button id="toggleSpin">Pause</button>
            <button id="resetView">Reset View</button>
          </div>
          <canvas id="glCanvas" width="900" height="560"></canvas>
        </section>
      </div>

      <footer>Arsalan Riaz</footer>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById("drawCanvas");
        const ctx = canvas.getContext("2d");
        const color = document.getElementById("color");
        const size = document.getElementById("size");
        const clearBtn = document.getElementById("clear");
        const saveBtn = document.getElementById("save");
        const toolPen = document.getElementById("toolPen");
        const toolEraser = document.getElementById("toolEraser");

        let drawing = false;
        let erasing = false;
        let lastX = 0,
          lastY = 0;
        function setCanvasScale() {
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const rect = canvas.getBoundingClientRect();
          const w = Math.max(600, rect.width);
          const h = w * (3 / 4);
          canvas.style.height = h + "px";
          canvas.width = w * dpr;
          canvas.height = h * dpr;
          ctx.scale(dpr, dpr);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
        }
        function getPos(e) {
          const r = canvas.getBoundingClientRect();
          const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
          const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
          return { x, y };
        }
        function start(e) {
          drawing = true;
          const p = getPos(e);
          lastX = p.x;
          lastY = p.y;
        }
        function draw(e) {
          if (!drawing) return;
          const p = getPos(e);
          ctx.globalCompositeOperation = erasing
            ? "destination-out"
            : "source-over";
          ctx.strokeStyle = color.value;
          ctx.lineWidth = +size.value;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
          lastX = p.x;
          lastY = p.y;
        }
        function end() {
          drawing = false;
        }

        toolPen.addEventListener("click", () => {
          erasing = false;
          toolPen.style.boxShadow = "0 0 0 2px var(--ring) inset";
          toolEraser.style.boxShadow = "none";
        });
        toolEraser.addEventListener("click", () => {
          erasing = true;
          toolEraser.style.boxShadow = "0 0 0 2px var(--ring) inset";
          toolPen.style.boxShadow = "none";
        });

        clearBtn.addEventListener("click", () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        });
        saveBtn.addEventListener("click", () => {
          const link = document.createElement("a");
          link.download = "sketch.png";
          const r = canvas.getBoundingClientRect();
          const tmp = document.createElement("canvas");
          tmp.width = r.width;
          tmp.height = r.height;
          const tctx = tmp.getContext("2d");
          tctx.drawImage(
            canvas,
            0,
            0,
            canvas.width,
            canvas.height,
            0,
            0,
            tmp.width,
            tmp.height,
          );
          link.href = tmp.toDataURL("image/png");
          link.click();
        });

        ["mousedown", "touchstart"].forEach((ev) =>
          canvas.addEventListener(ev, start),
        );
        ["mousemove", "touchmove"].forEach((ev) =>
          canvas.addEventListener(ev, draw),
        );
        ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach((ev) =>
          canvas.addEventListener(ev, end),
        );
        window.addEventListener("resize", () => {
          const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
          setCanvasScale();
          ctx.putImageData(img, 0, 0);
        });
        setCanvasScale();
        toolPen.click();
      })();

      (function () {
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");
        if (!gl) {
          alert("WebGL not supported");
          return;
        }

        const vertSrc = `
        attribute vec3 aPosition; 
        attribute vec3 aColor; 
        uniform mat4 uProj, uView, uModel; 
        varying vec3 vColor; 
        void main(){
          vColor = aColor; 
          gl_Position = uProj * uView * uModel * vec4(aPosition,1.0);
        }
      `;
        const fragSrc = `
        precision mediump float; 
        varying vec3 vColor; 
        void main(){ gl_FragColor = vec4(vColor, 1.0); }
      `;

        function compile(type, src) {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
            throw new Error(gl.getShaderInfoLog(s));
          return s;
        }
        function program(vs, fs) {
          const p = gl.createProgram();
          gl.attachShader(p, vs);
          gl.attachShader(p, fs);
          gl.linkProgram(p);
          if (!gl.getProgramParameter(p, gl.LINK_STATUS))
            throw new Error(gl.getProgramInfoLog(p));
          return p;
        }

        const prog = program(
          compile(gl.VERTEX_SHADER, vertSrc),
          compile(gl.FRAGMENT_SHADER, fragSrc),
        );
        gl.useProgram(prog);

        const positions = new Float32Array([
          // Front
          -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
          // Back
          -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1,
          // Top
          -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,
          // Bottom
          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
          // Right
          1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,
          // Left
          -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1,
        ]);
        const colors = new Float32Array([
          // Front (teal)
          0.15, 0.85, 0.9, 0.15, 0.85, 0.9, 0.15, 0.85, 0.9, 0.15, 0.85, 0.9,
          // Back (violet)
          0.66, 0.55, 1.0, 0.66, 0.55, 1.0, 0.66, 0.55, 1.0, 0.66, 0.55, 1.0,
          // Top (blue)
          0.3, 0.6, 1.0, 0.3, 0.6, 1.0, 0.3, 0.6, 1.0, 0.3, 0.6, 1.0,
          // Bottom (cyan)
          0.22, 0.95, 0.95, 0.22, 0.95, 0.95, 0.22, 0.95, 0.95, 0.22, 0.95,
          0.95,
          // Right (pink)
          1.0, 0.45, 0.74, 1.0, 0.45, 0.74, 1.0, 0.45, 0.74, 1.0, 0.45, 0.74,
          // Left (lime)
          0.55, 1.0, 0.55, 0.55, 1.0, 0.55, 0.55, 1.0, 0.55, 0.55, 1.0, 0.55,
        ]);
        const indices = new Uint16Array([
          0,
          1,
          2,
          0,
          2,
          3, // front
          4,
          5,
          6,
          4,
          6,
          7, // back
          8,
          9,
          10,
          8,
          10,
          11, // top
          12,
          13,
          14,
          12,
          14,
          15, // bottom
          16,
          17,
          18,
          16,
          18,
          19, // right
          20,
          21,
          22,
          20,
          22,
          23, // left
        ]);

        function buffer(data, attrib, size) {
          const buf = gl.createBuffer();
          const loc = gl.getAttribLocation(prog, attrib);
          gl.bindBuffer(gl.ARRAY_BUFFER, buf);
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(loc);
          gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
          return buf;
        }
        buffer(positions, "aPosition", 3);
        buffer(colors, "aColor", 3);
        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        const uProj = gl.getUniformLocation(prog, "uProj");
        const uView = gl.getUniformLocation(prog, "uView");
        const uModel = gl.getUniformLocation(prog, "uModel");

        function mat4() {
          return new Float32Array(16);
        }
        function identity(m) {
          for (let i = 0; i < 16; i++) m[i] = i % 5 === 0 ? 1 : 0;
          return m;
        }
        function perspective(out, fovy, aspect, near, far) {
          const f = 1 / Math.tan(fovy / 2);
          const nf = 1 / (near - far);
          out[0] = f / aspect;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = f;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = (far + near) * nf;
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = 2 * far * near * nf;
          out[15] = 0;
          return out;
        }
        function translate(out, x, y, z) {
          identity(out);
          out[12] = x;
          out[13] = y;
          out[14] = z;
          return out;
        }
        function rotateY(out, a) {
          identity(out);
          const c = Math.cos(a),
            s = Math.sin(a);
          out[0] = c;
          out[2] = s;
          out[8] = -s;
          out[10] = c;
          return out;
        }
        function rotateX(out, a) {
          identity(out);
          const c = Math.cos(a),
            s = Math.sin(a);
          out[5] = c;
          out[6] = -s;
          out[9] = s;
          out[10] = c;
          return out;
        }
        function multiply(out, a, b) {
          const o = new Float32Array(16);
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              o[i * 4 + j] =
                a[i * 4 + 0] * b[0 * 4 + j] +
                a[i * 4 + 1] * b[1 * 4 + j] +
                a[i * 4 + 2] * b[2 * 4 + j] +
                a[i * 4 + 3] * b[3 * 4 + j];
            }
          }
          out.set(o);
          return out;
        }

        function resize() {
          const dpr = Math.min(2, window.devicePixelRatio || 1);
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          gl.viewport(0, 0, canvas.width, canvas.height);
          const proj = perspective(
            mat4(),
            Math.PI / 3,
            canvas.width / canvas.height,
            0.1,
            100,
          );
          gl.uniformMatrix4fv(uProj, false, proj);
        }

        const view = translate(mat4(), 0, 0, -6);
        gl.uniformMatrix4fv(uView, false, view);

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.03, 0.05, 0.09, 1);

        let angleX = 0,
          angleY = 0;
        let t = 0;
        let spinning = true;
        const speedInput = document.getElementById("speed");
        document.getElementById("toggleSpin").onclick = () => {
          spinning = !spinning;
        };
        document.getElementById("resetView").onclick = () => {
          angleX = angleY = 0;
        };

        let dragging = false,
          lx = 0,
          ly = 0;
        canvas.addEventListener("mousedown", (e) => {
          dragging = true;
          lx = e.clientX;
          ly = e.clientY;
        });
        window.addEventListener("mouseup", () => (dragging = false));
        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          const dx = e.clientX - lx,
            dy = e.clientY - ly;
          lx = e.clientX;
          ly = e.clientY;
          angleY += dx * 0.01;
          angleX += dy * 0.01;
        });
        canvas.addEventListener("touchstart", (e) => {
          dragging = true;
          lx = e.touches[0].clientX;
          ly = e.touches[0].clientY;
        });
        window.addEventListener("touchend", () => (dragging = false));
        window.addEventListener("touchmove", (e) => {
          if (!dragging) return;
          const dx = e.touches[0].clientX - lx,
            dy = e.touches[0].clientY - ly;
          lx = e.touches[0].clientX;
          ly = e.touches[0].clientY;
          angleY += dx * 0.01;
          angleX += dy * 0.01;
        });

        function draw(now) {
          const sp = +speedInput.value / 1000;
          const dt = now - t || 16;
          t = now;
          if (spinning) {
            angleY += dt * sp;
            angleX += dt * sp * 0.4;
          }

          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          let model = mat4();
          let rY = rotateY(mat4(), angleY);
          let rX = rotateX(mat4(), angleX);
          model = multiply(model, rY, rX);
          gl.uniformMatrix4fv(uModel, false, model);
          gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
          requestAnimationFrame(draw);
        }

        resize();
        window.addEventListener("resize", resize);
        requestAnimationFrame(draw);
      })();
    </script>
  </body>
</html>
