<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interactive Creativity Website</title>
      <script
      src="https://greggman.github.io/webgl-lint/webgl-lint.js"
      crossorigin
    ></script>
    <script type="text/javascript" src="./Common/initShaders2.js"></script>
    <script type="text/javascript" src="./Common/MVnew.js"></script>
    <script type="text/javascript" src="./app.js"></script>
    <style>
      :root {
        --bg: #0b0d12;
        --panel: #11131a;
        --panel-2: #0f1220;
        --text: #e7ecf3;
        --muted: #9aa4b2;
        --accent: #6ee7ff;
        --accent-2: #a78bfa;
        --ring: #2dd4bf;
        --ok: #22c55e;
        --warn: #f59e0b;
        --bad: #ef4444;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Inter, "Helvetica Neue", Arial;
        color: var(--text);
        background:
          radial-gradient(1200px 800px at 80% -10%, #1a2142 0%, transparent 60%),
          var(--bg);
      }
      .wrap { max-width: 1100px; margin: 0 auto; padding: 28px 20px 56px; }
      header {
        display: grid; gap: 12px; align-items: end;
        grid-template-columns: 1fr auto; margin-bottom: 18px;
      }
      h1 { margin: 0; font-size: clamp(26px, 4.2vw, 40px); letter-spacing: .4px; }
      .badge {
        display: inline-flex; align-items: center; gap: 8px;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #051017; padding: 6px 12px; border-radius: 999px; font-weight: 700;
      }
      .grid { display: grid; gap: 18px; grid-template-columns: 1fr; }
      .card {
        background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
        border: 1px solid rgba(255,255,255,.08); border-radius: 18px; padding: 18px;
        box-shadow: 0 8px 30px rgba(0,0,0,.25); margin-bottom: 20px;
      }
      .card h2 { margin: 0 0 8px; font-size: 20px; }
      .card p { margin: 0 0 10px; color: var(--muted); }
      .toolbar {
        display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin: 8px 0 12px;
      }
      label { font-size: 13px; color: var(--muted); }
      input[type="color"], input[type="range"], button, select {
        background: var(--panel); color: var(--text); border: 1px solid rgba(255,255,255,.12);
        border-radius: 12px; padding: 8px 10px; outline: none;
      }
      input[type="color"] { padding: 0; height: 36px; width: 48px; }
      input[type="range"] { height: 36px; }
      button {
        cursor: pointer; transition: transform .05s ease, box-shadow .2s;
      }
      button:hover { box-shadow: 0 0 0 2px var(--ring) inset; }
      button:active { transform: translateY(1px); }

      canvas {
        display: block; width: 100%;
        background: conic-gradient(from 180deg at 50% 50%, rgba(255,255,255,.03), rgba(255,255,255,.01));
        border-radius: 14px; border: 1px solid rgba(255,255,255,.08);
      }
      #drawCanvas { aspect-ratio: 4/3; }
      #blankCanvas { width: 512px; height: 512px; margin: 0 auto; }

      .pill {
        display: inline-block; padding: 4px 10px; border-radius: 999px;
        background: rgba(255,255,255,.07); border: 1px solid rgba(255,255,255,.09);
        font-size: 12px; color: var(--muted);
      }

      /* Games */
      .game-wrap { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 18px; }
      @media (max-width: 980px) { .game-wrap { grid-template-columns: 1fr; } }

      /* Memory game grid */
      .grid-memory {
        display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
      }
      .card-mem {
        height: 84px; display: grid; place-items: center; font-size: 32px; cursor: pointer;
        border-radius: 12px;
        background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
        border: 1px solid rgba(255,255,255,.12);
        user-select: none; transition: transform .08s ease, box-shadow .2s;
      }
      .card-mem.flipped, .card-mem.matched { box-shadow: 0 0 0 2px var(--ring) inset; transform: scale(0.98); }

      /* Reaction test */
      .react-pad {
        height: 180px; border-radius: 12px; display: grid; place-items: center; text-align: center;
        border: 1px dashed rgba(255,255,255,.15);
        background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      }
      .react-pad.wait { background: rgba(245, 158, 11, .15); }
      .react-pad.go { background: rgba(34, 197, 94, .2); }

      /* Accuracy canvas */
      #accuracyCanvas { width: 100%; height: 320px; }

      footer { margin-top: 28px; color: var(--muted); text-align: center; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Interactive Creativity Website</h1>
          <p class="pill">Creativity Project</p>
        </div>
        <span class="badge" title="Course-aligned">Creative Theories</span>
      </header>

      <section class="card">
        <h2>About This Project</h2>
        <p>
          This website is a demonstration of creativity theory applied to a computer science project.
          By combining design, interactivity, and systems thinking, it highlights how creativity extends
          beyond art into technology and user-centered experiences.
        </p>
      </section>

      <section class="card">
        <h2>Theorists and Connections</h2>
        <p>Perspectives that shaped this site:</p>
        <ul>
          <li><strong>Teresa Amabile</strong> — intrinsic motivation supports deeper, more original work; the site invites play without external pressure.</li>
          <li><strong>Robert Sternberg</strong> — Investment Theory (“buy low, sell high” on ideas); this project invests in an atypical medium: an interactive, theory-informed site.</li>
          <li><strong>Mihaly Csikszentmihalyi</strong> — Systems Model (individual × domain × field); code/design (domain) meets feedback (field) and personal voice (individual).</li>
          <li><strong>Howard Gardner</strong> — Multiple intelligences; logical-mathematical (code), spatial (layout), linguistic (copy), intrapersonal (reflection).</li>
          <li><strong>Mark Runco</strong> — Everyday/developmental creativity; iterative features (sketching, games) cultivate process, not only “Big-C” outcomes.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Drawing Canvas</h2>
        <p>Use the tools below to sketch and create. This represents the open-ended, user-driven side of creativity.</p>
        <div class="toolbar" aria-label="Drawing toolbar">
          <label>Brush color <input type="color" id="color" value="#7EE3FF" /></label>
          <label>Brush size <input type="range" id="size" min="1" max="40" value="6" /></label>
          <button id="toolPen">Pen</button>
          <button id="toolEraser">Eraser</button>
          <button id="clear">Clear</button>
          <button id="save">Download PNG</button>
        </div>
        <canvas id="drawCanvas" width="900" height="675"></canvas>
      </section>

      <section class="card">
        <h2>3D Interactive View</h2>
        <p>This a interactive view that combines my CS course work with creativity. Use WASD to move around the spheres and click on them to change their colors. Q/E to zoom and out.</p>
        <canvas id="gl-canvas" width="512" height="512" aria-label="Blank canvas"></canvas>
      </section>

      <section class="card">
        <h2>Playground — Mini Games</h2>
        <div class="game-wrap">
          <!-- Memory Game -->
          <div class="card">
            <h3 style="margin:0 0 8px">Memory Game</h3>
            <p class="muted">Flip two cards to find a matching pair. Fewer moves = better memory strategy.</p>
            <div class="toolbar">
              <button id="memStart">New Game</button>
              <span id="memMoves" class="pill">Moves: 0</span>
              <span id="memFound" class="pill">Found: 0/8</span>
            </div>
            <div id="memoryGrid" class="grid-memory" aria-live="polite"></div>
          </div>

          <!-- Reaction Time Test -->
          <div class="card">
            <h3 style="margin:0 0 8px">Reaction Time Test</h3>
            <p class="muted">Click as soon as the pad turns green. Don’t jump the gun!</p>
            <div class="toolbar">
              <button id="reactStart">Start</button>
              <span id="reactLast" class="pill">Last: —</span>
              <span id="reactBest" class="pill">Best: —</span>
            </div>
            <div id="reactPad" class="react-pad" role="button" tabindex="0" aria-label="Reaction pad">
              <div id="reactMsg">Press <strong>Start</strong> to begin.</div>
            </div>
          </div>

          <!-- Click Accuracy Test -->
          <div class="card">
            <h3 style="margin:0 0 8px">Click Accuracy</h3>
            <p class="muted">Hit the moving targets. 30-second round. Accuracy = hits / clicks; we also track average time to hit.</p>
            <div class="toolbar">
              <button id="accStart">Start</button>
              <button id="accStop">Stop</button>
              <span id="accTimer" class="pill">Time: 30.0</span>
              <span id="accStats" class="pill">Hits: 0 | Clicks: 0 | Acc: 0% | Avg ms: —</span>
            </div>
            <canvas id="accuracyCanvas" width="900" height="320" aria-label="Click accuracy canvas"></canvas>
          </div>
        </div>
      </section>

      <footer>Arsalan Riaz</footer>
    </div>

    <script>
      /* ========= Drawing Canvas ========= */
      (function () {
        const canvas = document.getElementById("drawCanvas");
        const ctx = canvas.getContext("2d");
        const color = document.getElementById("color");
        const size = document.getElementById("size");
        const clearBtn = document.getElementById("clear");
        const saveBtn = document.getElementById("save");
        const toolPen = document.getElementById("toolPen");
        const toolEraser = document.getElementById("toolEraser");

        let drawing = false, erasing = false, lastX = 0, lastY = 0, scaled = false;

        function setCanvasScale() {
          // Avoid double scaling on repeated calls
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const rect = canvas.getBoundingClientRect();
          const w = Math.max(600, rect.width);
          const h = w * (3/4);
          canvas.style.height = h + "px";
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          ctx.setTransform(1,0,0,1,0,0);
          ctx.scale(dpr, dpr);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
        }

        function getPos(e) {
          const r = canvas.getBoundingClientRect();
          const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
          const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
          return { x, y };
        }
        function start(e) {
          drawing = true;
          const p = getPos(e);
          lastX = p.x; lastY = p.y;
        }
        function draw(e) {
          if (!drawing) return;
          const p = getPos(e);
          ctx.globalCompositeOperation = erasing ? "destination-out" : "source-over";
          ctx.strokeStyle = color.value;
          ctx.lineWidth = +size.value;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
          lastX = p.x; lastY = p.y;
        }
        function end() { drawing = false; }

        toolPen.addEventListener("click", () => {
          erasing = false;
          toolPen.style.boxShadow = "0 0 0 2px var(--ring) inset";
          toolEraser.style.boxShadow = "none";
        });
        toolEraser.addEventListener("click", () => {
          erasing = true;
          toolEraser.style.boxShadow = "0 0 0 2px var(--ring) inset";
          toolPen.style.boxShadow = "none";
        });

        clearBtn.addEventListener("click", () => {
          const rect = canvas.getBoundingClientRect();
          ctx.clearRect(0, 0, rect.width, rect.height);
        });
        saveBtn.addEventListener("click", () => {
          const link = document.createElement("a");
          link.download = "sketch.png";
          // Export at CSS pixel size for crispness
          const r = canvas.getBoundingClientRect();
          const tmp = document.createElement("canvas");
          tmp.width = r.width; tmp.height = r.height;
          const tctx = tmp.getContext("2d");
          // DrawImage scales down from device pixels to CSS pixels
          tctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, tmp.width, tmp.height);
          link.href = tmp.toDataURL("image/png");
          link.click();
        });

        ["mousedown","touchstart"].forEach(ev => canvas.addEventListener(ev, start, {passive:true}));
        ["mousemove","touchmove"].forEach(ev => canvas.addEventListener(ev, draw, {passive:true}));
        ["mouseup","mouseleave","touchend","touchcancel"].forEach(ev => canvas.addEventListener(ev, end));

        window.addEventListener("resize", () => {
          // Optional: keep current drawing by snapshot-and-restore at CSS size
          const r = canvas.getBoundingClientRect();
          const snap = document.createElement("canvas");
          snap.width = r.width; snap.height = r.height;
          snap.getContext("2d").drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, snap.width, snap.height);
          setCanvasScale();
          ctx.drawImage(snap, 0, 0, snap.width, snap.height);
        });

        setCanvasScale();
        toolPen.click();
      })();

      /* ========= Memory Game ========= */
      (function () {
        const grid = document.getElementById("memoryGrid");
        const btn = document.getElementById("memStart");
        const movesEl = document.getElementById("memMoves");
        const foundEl = document.getElementById("memFound");

        const EMOJIS = ["🌸","🪐","⚡","🎧","🍀","🌙","🔥","🧩"];
        let deck = [], first = null, lock = false, moves = 0, found = 0;

        function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

        function newGame() {
          grid.innerHTML = "";
          deck = shuffle([...EMOJIS, ...EMOJIS]).map((emoji, i) => ({ id:i, emoji, matched:false }));
          moves = 0; found = 0; updateHud();
          deck.forEach(card => {
            const el = document.createElement("div");
            el.className = "card-mem";
            el.dataset.id = card.id;
            el.textContent = "❔";
            el.addEventListener("click", () => flip(el, card));
            grid.appendChild(el);
          });
        }

        function updateHud(){
          movesEl.textContent = `Moves: ${moves}`;
          foundEl.textContent = `Found: ${found}/${EMOJIS.length}`;
        }

        function flip(el, card){
          if (lock || card.matched || el.classList.contains("flipped")) return;
          el.classList.add("flipped");
          el.textContent = card.emoji;

          if (!first) {
            first = { el, card };
          } else {
            moves++;
            if (first.card.emoji === card.emoji) {
              first.card.matched = card.matched = true;
              first.el.classList.add("matched");
              el.classList.add("matched");
              first = null;
              found++;
              updateHud();
              if (found === EMOJIS.length) {
                setTimeout(()=>alert(`Nice! You won in ${moves} moves.`), 300);
              }
            } else {
              lock = true;
              setTimeout(() => {
                first.el.classList.remove("flipped");
                first.el.textContent = "❔";
                el.classList.remove("flipped");
                el.textContent = "❔";
                first = null;
                lock = false;
                updateHud();
              }, 650);
            }
          }
        }

        btn.addEventListener("click", newGame);
        newGame();
      })();

      /* ========= Reaction Time Test ========= */
      (function () {
        const startBtn = document.getElementById("reactStart");
        const pad = document.getElementById("reactPad");
        const msg = document.getElementById("reactMsg");
        const lastEl = document.getElementById("reactLast");
        const bestEl = document.getElementById("reactBest");

        let state = "idle"; // idle -> waiting -> go
        let timer = null;
        let goTime = 0;
        let best = Infinity;

        function resetPad() {
          pad.classList.remove("wait", "go");
          msg.innerHTML = 'Press <strong>Start</strong> to begin.';
          state = "idle";
          if (timer) { clearTimeout(timer); timer = null; }
        }

        function start() {
          if (state !== "idle") resetPad();
          state = "waiting";
          msg.textContent = "Wait for green…";
          pad.classList.add("wait");
          const delay = 1200 + Math.random() * 1800;
          timer = setTimeout(() => {
            state = "go";
            pad.classList.remove("wait");
            pad.classList.add("go");
            msg.textContent = "GO! Click now!";
            goTime = Date.now();
          }, delay);
        }

        function attempt() {
          if (state === "waiting") {
            // Too early
            clearTimeout(timer); timer = null;
            msg.textContent = "Too early! Click Start to try again.";
            pad.classList.remove("wait");
            state = "idle";
          } else if (state === "go") {
            const now = Date.now();
            const rt = now - goTime;
            lastEl.textContent = `Last: ${rt} ms`;
            if (rt < best) {
              best = rt;
              bestEl.textContent = `Best: ${best} ms`;
            }
            resetPad();
          }
        }

        startBtn.addEventListener("click", start);
        pad.addEventListener("click", attempt);
        pad.addEventListener("keydown", (e) => { if (e.key === " " || e.key === "Enter") attempt(); });
      })();

      /* ========= Click Accuracy (fixed: Date.now bug) ========= */
      (function () {
        const canvas = document.getElementById("accuracyCanvas");
        const ctx = canvas.getContext("2d");
        const startBtn = document.getElementById("accStart");
        const stopBtn  = document.getElementById("accStop");
        const timerEl  = document.getElementById("accTimer");
        const statsEl  = document.getElementById("accStats");

        let playing = false;
        let target = null;
        let hits = 0, clicks = 0;
        let spawnAt = 0; // ms
        let hitTimes = []; // ms
        let roundEndAt = 0; // ms
        let raf = null;

        function resize() {
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const rect = canvas.getBoundingClientRect();
          canvas.width = Math.floor(rect.width * dpr);
          canvas.height = Math.floor(rect.height * dpr);
          ctx.setTransform(1,0,0,1,0,0);
          ctx.scale(dpr, dpr);
          draw();
        }

        function spawnTarget() {
          const rect = canvas.getBoundingClientRect();
          const r = 18 + Math.random() * 12;
          const pad = r + 10;
          const x = pad + Math.random() * (rect.width - pad*2);
          const y = pad + Math.random() * (rect.height - pad*2);
          target = { x, y, r };
          spawnAt = Date.now(); // <-- fixed
        }

        function start() {
          if (playing) return;
          playing = true;
          hits = 0; clicks = 0; hitTimes = [];
          roundEndAt = Date.now() + 30000; // 30s
          spawnTarget();
          loop();
        }

        function stop() {
          playing = false;
          if (raf) cancelAnimationFrame(raf);
          draw();
        }

        function updateHud() {
          const now = Date.now(); // <-- fixed
          const remain = Math.max(0, roundEndAt - now);
          timerEl.textContent = `Time: ${(remain/1000).toFixed(1)}`;
          const acc = clicks ? Math.round((hits / clicks) * 100) : 0;
          const avg = hitTimes.length ? Math.round(hitTimes.reduce((a,b)=>a+b,0) / hitTimes.length) : "—";
          statsEl.textContent = `Hits: ${hits} | Clicks: ${clicks} | Acc: ${acc}% | Avg ms: ${avg}`;
        }

        function draw() {
          const rect = canvas.getBoundingClientRect();
          ctx.clearRect(0,0,rect.width,rect.height);

          // background grid (subtle)
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          for (let x=0; x<rect.width; x+=40) {
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,rect.height); ctx.stroke();
          }
          for (let y=0; y<rect.height; y+=40) {
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(rect.width,y); ctx.stroke();
          }
          ctx.restore();

          if (target) {
            // outer ring
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.r+6, 0, Math.PI*2);
            ctx.strokeStyle = "rgba(167,139,250,.8)";
            ctx.lineWidth = 2;
            ctx.stroke();
            // filled circle
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.r, 0, Math.PI*2);
            ctx.fillStyle = "rgba(34,212,191,.9)";
            ctx.fill();
          }
        }

        function loop() {
          if (!playing) return;
          const now = Date.now(); // <-- fixed
          if (now >= roundEndAt) {
            stop();
            return;
          }
          updateHud();
          draw();
          // drift the target a bit for challenge
          if (target) {
            target.x += Math.sin(now/350) * 0.4;
            target.y += Math.cos(now/420) * 0.4;
          }
          raf = requestAnimationFrame(loop);
        }

        function onClick(e) {
          if (!playing || !target) return;
          clicks++;
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const dx = x - target.x, dy = y - target.y;
          const hit = (dx*dx + dy*dy) <= (target.r * target.r);
          if (hit) {
            hits++;
            const rt = Date.now() - spawnAt; // <-- fixed
            hitTimes.push(rt);
            spawnTarget();
          }
          updateHud();
          draw();
        }

        startBtn.addEventListener("click", start);
        stopBtn.addEventListener("click", stop);
        canvas.addEventListener("click", onClick);
        window.addEventListener("resize", resize);
        resize();
        updateHud();
      })();
    </script>
  </body>
</html>
